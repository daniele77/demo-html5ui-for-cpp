/*******************************************************************************
* Copyright (C) 2017 Daniele Pallastrelli
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
******************************************************************************/

#include <string>
#include <functional>
#include <boost/asio.hpp>
#include <boost/beast/core.hpp>
#include <boost/beast/websocket.hpp>

class WebSocketClient
{
public:

    using ConnectHandler = std::function< void(const boost::system::error_code&) >;
    using ReceiveHandler = std::function< void(const std::string&, const boost::system::error_code&) >;

    WebSocketClient(boost::asio::io_service& _ios, std::string _host, std::string _port) :
        ios(_ios), host(std::move(_host)), port(std::move(_port)), resolver(ios), socket(ios), websocket(socket)
    {}

    WebSocketClient() = delete;
    WebSocketClient(const WebSocketClient&) = delete;
    WebSocketClient(WebSocketClient&&) = delete;
    WebSocketClient& operator = (const WebSocketClient&) = delete;

    ~WebSocketClient() noexcept
    {
        Close();
    }

    void Connect(std::string req, ConnectHandler h)
    {
        request = std::move(req);
        onConnection = std::move(h);
        resolver.async_resolve(
            boost::asio::ip::tcp::resolver::query{ host, port },
            [this](const boost::system::error_code& ec, boost::asio::ip::tcp::resolver::iterator i)
        {
            if (ec) onConnection(ec);
            else Resolved(i);
        }
        );
    }

    void Close() noexcept
    {
        try
        {
            if (socket.is_open())
            {
                if (connected)
                    websocket.close(boost::beast::websocket::close_code::normal);
                socket.cancel();
                socket.close();
            }
        }
        catch (const std::exception&)
        {
            // nothing to do
        }
    }

    void Receive(ReceiveHandler h)
    {
        onReceive = std::move(h);
        Read();
    }

private:

    void Resolved(boost::asio::ip::tcp::resolver::iterator i)
    {
        boost::asio::async_connect(
            socket,
            i,
            [this](boost::system::error_code e, boost::asio::ip::tcp::resolver::iterator)
        {
            if (e) onConnection(e);
            else Connected();
        }
        );
    }

    void Connected()
    {
        websocket.async_handshake(host, request, [this](boost::beast::error_code ec) {
            connected = true;
            onConnection(ec);
        });
    }

    void Read()
    {
        websocket.async_read(
            rxData,
            [this](boost::system::error_code ec, std::size_t /* bytes */) { Received(ec); }
        );
    }

    void Received(boost::system::error_code ec)
    {
        std::string s((std::istreambuf_iterator<char>(&rxData)), std::istreambuf_iterator<char>());
#ifdef ARICPP_TRACE_WEBSOCKET
        if (ec) std::cerr << "*** websocket error: " << ec.message() << '\n';
        else std::cerr << "*** <== " << s << '\n';
#endif
        if (ec) onReceive(std::string(), ec);
        else onReceive(s, ec);
        rxData.consume(rxData.size());
        if (ec != boost::asio::error::eof && ec != boost::asio::error::operation_aborted) Read();
    }

    bool connected = false;
    boost::asio::io_service& ios;
    const std::string host;
    const std::string port;

    boost::asio::ip::tcp::resolver resolver;
    boost::asio::ip::tcp::socket socket;
    boost::beast::websocket::stream< boost::asio::ip::tcp::socket& > websocket;
    boost::asio::streambuf rxData;

    std::string request;
    ConnectHandler onConnection;
    ReceiveHandler onReceive;
};


/////////////////////////////////////////////////////////

#include <boost/asio.hpp>
#include <boost/beast/core.hpp>
#include <boost/beast/websocket.hpp>
#include <vector>
#include <memory>
#include <queue>

//#define BEAST_OLD_VERSION

using endpoint_type = boost::asio::ip::tcp::endpoint;
using err_code = boost::beast::error_code;
using address_type = boost::asio::ip::address;
using socket_type = boost::asio::ip::tcp::socket;

class WsSession : public std::enable_shared_from_this<WsSession>
{
public:
    virtual ~WsSession() = default;
    WsSession(endpoint_type const& ep, socket_type&& sock) : endpoint(ep), ws(std::move(sock)) {}
    virtual void Start();
    void Send(const std::string& data);
    const endpoint_type& EndPoint() const { return endpoint; }
protected:
    virtual void OnConnect() = 0;
    virtual void OnDisconnect() = 0;
    virtual void OnError(const std::string& msg) = 0;
    virtual void OnDataReceived(const std::string& data) = 0;
private:
    void OnAccept(err_code ec);
    void Read();
    void OnRead(err_code ec);
    void OnWrite(err_code ec);
    void Transmit();
    void fail(std::string what, err_code ec);

    const endpoint_type endpoint;
    boost::beast::websocket::stream<socket_type> ws;
    boost::asio::streambuf rxData;
    std::string txData;

    std::queue<std::string> txQueue;
};

////////////////////////////////////////////////////////////////////////

class WsServer
{
public:
    virtual ~WsServer() = default;
    WsServer(WsServer const&) = delete;
    WsServer& operator=(WsServer const&) = delete;
    explicit WsServer(boost::asio::io_service& ios) :
        socket(ios),
        acceptor(ios)
    {}
    void Open(endpoint_type const& ep);

protected:
    virtual std::shared_ptr<WsSession> CreateSession(const endpoint_type& ep, boost::asio::ip::tcp::socket socket) = 0;
    virtual void OnError(const std::string& msg);

private:

    void Accept();
    void OnAccept(err_code ec);
    void fail(std::string what, err_code ec);

    socket_type socket;
    endpoint_type ep_;
    boost::asio::ip::tcp::acceptor acceptor;
};

constexpr auto queueMaxSize = 50;

void WsSession::Start()
{
    OnConnect();
    auto self = shared_from_this();
#ifdef BEAST_OLD_VERSION
    ws.async_accept(
#else
    ws.async_accept_ex(
        [](boost::beast::websocket::response_type& res)
    {
        res.set(boost::beast::http::field::server, "WS-Server");
    },
#endif
        [self](err_code e) { self->OnAccept(e); }
    );
}

void WsSession::Send(const std::string& data)
{
    // check for queue too large
    if (txQueue.size() > queueMaxSize)
    {
        std::queue<std::string>().swap(txQueue); // clear the queue
        OnError("TX queue overflow");
        return;
    }

    // in any case, we insert it in the queue
    txQueue.push(data);

    if (txQueue.size() == 1) // currently not transmitting
        Transmit();
}

void WsSession::OnAccept(err_code ec)
{
    if (ec) return fail("async_accept", ec);
    Read();
}

void WsSession::Read()
{
    auto self = shared_from_this();
    // read message
#ifdef BEAST_OLD_VERSION
    static beast::websocket::opcode unusedOpcode;
    ws.async_read(unusedOpcode, rxData, [self](auto e) { self->OnRead(e); });
#else
    ws.async_read(rxData, [self](boost::system::error_code e, std::size_t /* bytes */) { self->OnRead(e); });
#endif
}

void WsSession::OnRead(err_code ec)
{
    if (ec == boost::beast::websocket::error::closed)
    {
        OnDisconnect();
        return;
    }
    if (ec) return fail("async_read", ec);
    std::string s((std::istreambuf_iterator<char>(&rxData)), std::istreambuf_iterator<char>());
    OnDataReceived(s);
    rxData.consume(rxData.size());
    // if ( ec != boost::asio::error::eof && ec != boost::asio::error::operation_aborted )
    Read();
}

void WsSession::OnWrite(err_code ec)
{
    if (ec) fail("async_write", ec);
    if (txQueue.empty()) return; // we have aborted becase the queue was too large

    // remove element from queue (the first is the one we have transmitted)
    txQueue.pop();

    if (!txQueue.empty()) // more to transmit
        Transmit();
}

void WsSession::Transmit()
{
    txData = txQueue.front();
#ifndef BEAST_OLD_VERSION
    ws.text(true);
#endif
    auto self = shared_from_this();
    ws.async_write(boost::asio::buffer(txData), [self](auto e, std::size_t) { self->OnWrite(e); });
}

void WsSession::fail(std::string what, err_code ec)
{
    what += ": " + ec.message();;
    OnError(what);
}


////////////////////////////////////////////////////////////////////////


void WsServer::Open(endpoint_type const& ep)
{
    err_code ec;
    acceptor.open(ep.protocol(), ec);
    if (ec) return fail("open", ec);
    acceptor.set_option(boost::asio::socket_base::reuse_address{ true });
    acceptor.bind(ep, ec);
    if (ec) return fail("bind", ec);
    acceptor.listen(boost::asio::socket_base::max_connections, ec);
    if (ec) return fail("listen", ec);
    Accept();
}

void WsServer::Accept()
{
    acceptor.async_accept(socket, ep_, std::bind(&WsServer::OnAccept, this, std::placeholders::_1));
}

void WsServer::OnAccept(err_code ec)
{
    if (!acceptor.is_open()) return;
    if (ec == boost::asio::error::operation_aborted) return;
    if (ec) fail("accept", ec);
    CreateSession(ep_, std::move(socket))->Start();
    Accept();
}

void WsServer::fail(std::string what, err_code ec)
{
    what += ": " + ec.message();
    OnError(what);
}

void WsServer::OnError(const std::string& msg)
{
    std::cerr << "WsServer error: " << msg << std::endl;
}



/////////////////////////////////////////////////////////

//#include "json.hpp"

class Session : public WsSession
{
public:
    using ReqHandler = std::function<void(const std::string& request)>;
    using DiscHandler = std::function<void()>;

    Session(const std::string& address, endpoint_type const& ep, socket_type&& sock, ReqHandler& rh, DiscHandler& dh) :
        WsSession(ep, std::move(sock)),
        reqHandler(rh),
        discHandler(dh)
    {
        std::cout << "New WS Session " << std::hex << this << std::dec
            << " address=" << address << std::endl;
    }

    ~Session()
    {
    }
protected:
    void OnConnect() override
    {
        std::cout << "WS connected" << std::endl;
    }
    void OnDisconnect() override
    {
        std::cout << "WS disconnected" << std::endl;
        discHandler();
    }
    void OnError(const std::string& msg) override
    {
        std::cerr << "WS error: " << msg << std::endl;
    }
    void OnDataReceived(const std::string& data) override
    {
        reqHandler(data);
    }
private:
    ReqHandler& reqHandler;
    DiscHandler& discHandler;
};

/////////////////////////////////////////////////////

class WsInterface : public WsServer
{
public:
    using ReqHandler = std::function<void(const std::string& request)>;
    using DiscHandler = std::function<void()>;
    WsInterface(boost::asio::io_service& ios) : WsServer(ios)
    {
        static constexpr unsigned short port = 9971;
        WsServer::Open(endpoint_type{ address_type::from_string("0.0.0.0"), port });
        std::cout << "Web socket listening on port " << port << std::endl;
    }
    void RequestHandler(ReqHandler h) { reqHandler = h; }
    void DisconnectionHandler(DiscHandler h) { discHandler = h; }
    void SendEvent(const std::string& msg)
    {
        for (auto& addAndSession : sessions)
        {
            if (auto session = addAndSession.second.lock())
                session->Send(msg);
            else
                std::cerr << "Session expired in session list" << std::endl;
        }
    }
protected:
    std::shared_ptr<WsSession> CreateSession(const endpoint_type& ep, boost::asio::ip::tcp::socket socket) override
    {
        Clean();
        auto address = Address(ep);
        auto s = std::make_shared<Session>(address, ep, std::move(socket), reqHandler, discHandler);
        sessions[address] = std::weak_ptr<Session>(s);
        return s;
    }
private:
    static std::string Address(const endpoint_type& ep)
    {
        return ep.address().to_string() + ':' + std::to_string(ep.port());
    }

    void Clean()
    {
        auto i = sessions.begin();
        while (i != sessions.end())
        {
            if ((*i).second.expired())
                i = sessions.erase(i);
            else
                ++i;
        }
    }

    using Sessions = std::unordered_map<std::string, std::weak_ptr<Session>>; // address, session
    Sessions sessions;
    ReqHandler reqHandler;
    DiscHandler discHandler;
};

///////////////////////////////////////////////////

#include <boost/asio/steady_timer.hpp>
#include <chrono>
#include <random>

class DummySoftPhone
{
public:
    using LevHandler = std::function<void(unsigned,unsigned)>;

    DummySoftPhone(boost::asio::io_service& _ios, LevHandler levHandler) : 
        connTimer(_ios),
        levelTimer(_ios),
        levelHandler(levHandler),
        rng(rd()),
        distribution(5, 95)
        //distribution(30)
    {
        StartTimer();
    }
    template <typename ConnectionHandler>
    void Connect(
        const std::string& server,
        const std::string& user,
        const std::string& password,
        ConnectionHandler&& handler
    )
    {
        std::cout << "Trying registration to registrar: "
            << server
            << " user: " << user
            << " password: " << password << std::endl;
        using namespace std::chrono_literals;
        connTimer.expires_from_now(2s);
        connTimer.async_wait(
            [this, handler, server, user, password](const boost::system::error_code&)
            {
                connected = ( (server == "127.0.0.1" || server == "localhost") &&
                              (user == "daniele" && password == "123456") );
                handler(connected);
                if (connected) std::cout << "Registration ok" << std::endl;
                else std::cout << "Registration failed" << std::endl;
            }
        );
    }
    void Autoanswer(bool active)
    {
        std::cout << "Autoanswer: " << std::boolalpha << active << std::endl;
        autoanswer = active;
    }
    void AGC(bool active)
    {
        std::cout << "AGC: " << std::boolalpha << active << std::endl;
        agc = active;
    }
    void Call(const std::string& num)
    {
        std::cout << "Calling: " << num << std::endl;
        conversation = true;
    }
    void Answer()
    {
        std::cout << "Answer" << std::endl;
        conversation = true;
    }
    void Hangup()
    {
        std::cout << "Hangup" << std::endl;
        conversation = false;
    }
    void Volume(unsigned vol)
    {
        std::cout << "Set Volume to: " << vol << std::endl;
    }
private:
    void StartTimer()
    {
        using namespace std::chrono_literals;
        levelTimer.expires_from_now(500ms);
        levelTimer.async_wait(
            [this](const boost::system::error_code&)
            {
                ChangeLevels();
                StartTimer();
            }
        );
    }

    void ChangeLevels()
    {
        if (!conversation) return;
        const unsigned mic = distribution(rng);
        const unsigned sp = distribution(rng);
        levelHandler(mic, sp);
    }
    boost::asio::steady_timer connTimer;
    boost::asio::steady_timer levelTimer;
    LevHandler levelHandler;
    bool connected = false;
    bool autoanswer = false;
    bool agc = false;
    bool conversation = false;
    std::random_device rd;
    std::mt19937 rng;
    std::uniform_int_distribution<int> distribution;
    //std::poisson_distribution<int> distribution;
};

///////////////////////////////////////////////////

// hide the DOS black console
// #pragma comment(linker, "/SUBSYSTEM:windows /ENTRY:mainCRTStartup")

#include <iostream>
#include "json.hpp"

using namespace std;
using json = nlohmann::json;

int main()
{
    boost::asio::io_service ios;
    WsInterface ws(ios);
    string server;
    string user;
    string password;
    string number;
    bool agc = false;
    bool autoanswer = false;
    DummySoftPhone softPhone(
        ios,
        [&ws](unsigned mic, unsigned sp)
        {
            ws.SendEvent("document.getElementById('mic').style.width = '" + std::to_string(mic) + "%';");
            ws.SendEvent("document.getElementById('speaker').style.width = '" + std::to_string(sp) + "%';");
        }
    );

    map<pair<string,string>, function<void(json)>> handlers;

    handlers[make_pair("connectbtn","onclick")] = [&](const json& event)
    {
        softPhone.Connect(server, user, password,
            [&ws](bool connected)
            {
                std::string value = "Unregistered";
                if (connected) value = "Registered";
                ws.SendEvent("document.getElementById('status').innerHTML = '" + value + "';");
            }
        );
    };

    handlers[make_pair("callbtn", "onclick")] = [&](const json& event)
    {
        softPhone.Call(number);
    };

    handlers[make_pair("answerbtn", "onclick")] = [&](const json& event)
    {
        softPhone.Answer();
    };

    handlers[make_pair("hangupbtn", "onclick")] = [&](const json& event)
    {
        softPhone.Hangup();
    };

    handlers[make_pair("autoanswer", "onclick")] = [&](const json& event)
    {
        autoanswer = !autoanswer;
        softPhone.Autoanswer(autoanswer);
    };

    handlers[make_pair("agc", "onclick")] = [&](const json& event)
    {
        agc = !agc;
        softPhone.AGC(agc);
    };

    handlers[make_pair("server", "oninput")] = [&](const json& event)
    {
        server = event.at("value");
    };

    handlers[make_pair("user", "oninput")] = [&](const json& event)
    {
        user = event.at("value");
    };

    handlers[make_pair("password", "oninput")] = [&](const json& event)
    {
        password = event.at("value");
    };

    handlers[make_pair("number", "oninput")] = [&](const json& event)
    {
        number = event.at("value");
    };

    handlers[make_pair("volume", "oninput")] = [&](const json& event)
    {
        const std::string str = event.at("value");
        softPhone.Volume(std::stoul(str));
    };


    // close the application on the client disconnection
    ws.DisconnectionHandler([&ios]() { /*ios.stop();*/  });

    ws.RequestHandler(
        [&](const std::string& req)
    {
        //std::cout << "Request: " << req << std::endl;
        try
        {
            using json = nlohmann::json;

            auto jsonObj = json::parse(req);
            string id = jsonObj.at("id");
            string event = jsonObj.at("event");

            auto handler = handlers.find(std::make_pair(id, event));
            if (handler != handlers.end())
                handler->second(jsonObj);
        }
        catch (const std::exception& e)
        {
            std::cerr << "WS: bad message received. " << e.what()
                << " Message was: " << req << std::endl;
        }
    }
    );

    ios.run();
    return 0;
}
